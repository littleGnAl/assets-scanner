// Copyright (C) 2020 littlegnal
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'package:meta/meta.dart';

import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

class _AssetsScannerOptions {
  const _AssetsScannerOptions._(
      {this.path = "lib", this.className = "R", this.ignoreComment = false});
  factory _AssetsScannerOptions() => _AssetsScannerOptions._();
  factory _AssetsScannerOptions.fromYamlMap(YamlMap map) {
    return _AssetsScannerOptions._(
        path: map["path"] ?? "lib",
        className: map["className"] ?? "R",
        ignoreComment: map["ignoreComment"] ?? false);
  }

  /// The path where the `r.dart` file locate. Note that the `path` should be
  /// sub-path of `lib/`.
  final String path;

  /// The class name of the `r.dart`.
  final String className;

  /// Indicate the comments need to be generated or not. Note that the you can't
  /// preview the images assets if `ignoreComment` is `true`.
  final bool ignoreComment;

  @override
  String toString() =>
      "_AssetsScannerOptions(path: $path, className: $className, ignoreComment: $ignoreComment)";
}

@visibleForOverriding
const String rFileHeader =
    '/// GENERATED BY assets_scanner. DO NOT MODIFY BY HAND.\n'
    '/// See more detail on https://github.com/littleGnAl/assets-scanner.';

@visibleForOverriding
const ignoreForFile = '// ignore_for_file:'
    'lines_longer_than_80_chars,'
    'constant_identifier_names';

/// [AssetsBuilder] will get the assets path from `pubspec.yaml` and generate
/// a `r.dart` with `const` properties of assets path by default. You can custom
/// it by adding an `assets_scanner_options.yaml` file, and the supported key
/// is same with [_AssetsScannerOptions]'s properties name.
class AssetsBuilder extends Builder {
  @override
  Map<String, List<String>> get buildExtensions {
    final options = _getOptions();
    String extensions = 'r.dart';
    if (options.path != 'lib' && options.path.startsWith("lib/")) {
      extensions = options.path.replaceFirst("lib/", "") + "/" + extensions;
    }
    // TODO(littlegnal): It's so wired that this works, but the `buildExtensions` here not
    // match the `build_extensions` in the `build.yaml` file. Need more research see
    // if it's a correct way.
    return {
      r'$lib$': ["$extensions"]
    };
  }

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final pubspecYamlMap = await _createPubspecYampMap(buildStep);
    if (pubspecYamlMap?.isEmpty ?? true) return;

    final options = _getOptions();
    if (!options.path.startsWith('lib')) {
      log.severe(
          "The custom path in assets_scanner_options.yaml should be sub-path of lib/.");
      return;
    }

    final rClass =
        await _generateRFileContent(buildStep, pubspecYamlMap, options);
    if (rClass.isEmpty) return;

    final dir = options.path.startsWith('lib') ? options.path : 'lib';
    final output = AssetId(buildStep.inputId.package, p.join(dir, "r.dart"));
    await buildStep.writeAsString(output, rClass);
  }

  Future<String> _generateRFileContent(BuildStep buildStep,
      YamlMap pubspecYamlMap, _AssetsScannerOptions options) async {
    String assetPathsClass =
        await _createRClass(pubspecYamlMap, buildStep, options);

    String packageAssetPathsClass = _createPackageAssetsClass(pubspecYamlMap);

    final hasAnyPaths =
        assetPathsClass.isNotEmpty || packageAssetPathsClass.isNotEmpty;
    if (!hasAnyPaths) {
      return "";
    }

    StringBuffer rFileContent = StringBuffer();
    if (hasAnyPaths) {
      rFileContent.writeln(rFileHeader);
    }
    if (assetPathsClass.isNotEmpty) {
      rFileContent.write(assetPathsClass.toString());
    }
    if (packageAssetPathsClass.isNotEmpty) {
      if (assetPathsClass.isNotEmpty) {
        rFileContent.writeln();
      }

      rFileContent.write(packageAssetPathsClass.toString());
    }

    return rFileContent.toString();
  }

  Future<String> _createRClass(YamlMap pubspecYamlMap, BuildStep buildStep,
      _AssetsScannerOptions options) async {
    final assetPaths =
        await _findAssetIdPathsFromFlutterAssetsList(buildStep, pubspecYamlMap);
    StringBuffer assetPathsClass = StringBuffer();
    if (assetPaths.isNotEmpty) {
      // Create default asset paths class.
      assetPathsClass.writeln('class ${options.className} {');
      assetPathsClass
          .writeln('  static const package = "${buildStep.inputId.package}";');
      assetPathsClass.writeln();
      assetPaths.forEach((assetPath) {
        // Ignore the parent path to make the property name shorter.
        String propertyName = assetPath
            .substring(assetPath.indexOf("/") + 1, assetPath.lastIndexOf("."))
            .replaceAll('/', '_');

        if (propertyName.isNotEmpty) {
          if (!options.ignoreComment) {
            assetPathsClass.writeln("  /// ![](${p.absolute(assetPath)})");
          }
          assetPathsClass
              .writeln("  static const $propertyName = \"${assetPath}\";");
          assetPathsClass.writeln();
        }
      });
      assetPathsClass.writeln(ignoreForFile);
      assetPathsClass.writeln('}');
    }

    return assetPathsClass.toString();
  }

  String _createPackageAssetsClass(YamlMap pubspecYamlMap) {
    Set<String> assetPaths = _getAssetsListFromPubspec(pubspecYamlMap);
    Set<String> pubspecDependencies;
    Map<String, Map<String, String>> packageAssetPaths;
    for (final assetPath in assetPaths) {
      // Handle the package assets, more detail about the directory structure:
      // https://flutter.dev/docs/development/ui/assets-and-images#bundling-of-package-assets
      if (assetPath.startsWith('packages')) {
        final assetPathSegments = assetPath.split('/');
        if (assetPathSegments.length >= 2) {
          pubspecDependencies ??= _getPackagesFromPubspec(pubspecYamlMap);
          final packageName = assetPathSegments[1];

          if (pubspecDependencies.contains(packageName)) {
            packageAssetPaths ??= {};
            final assetPathsOfPackge =
                packageAssetPaths.putIfAbsent(packageName, () => {});
            final actualAssetPath = assetPath.substring(
                // The length of `packages/<package-name>/`
                assetPath.indexOf(packageName) + packageName.length + 1);
            final propertyName = actualAssetPath
                .substring(0, actualAssetPath.lastIndexOf("."))
                .replaceAll('/', '_');
            assetPathsOfPackge[propertyName] = actualAssetPath;
          }
        }
      }
    }

    StringBuffer packageAssetPathsClass = StringBuffer();
    if (packageAssetPaths != null) {
      // Create package asset paths class.
      packageAssetPaths.forEach((packageName, assetPaths) {
        String className = '';
        if (packageName.contains('_')) {
          final tempSegments = packageName.split('_');
          tempSegments.forEach((element) {
            className +=
                (element.substring(0, 1).toUpperCase() + element.substring(1));
          });
        } else {
          className = packageName.substring(0, 1).toUpperCase() +
              packageName.substring(1);
        }
        packageAssetPathsClass.writeln('class $className {');
        packageAssetPathsClass
            .writeln('  static const package = "$packageName";');
        packageAssetPathsClass.writeln();
        assetPaths.forEach((propertyName, assetPath) {
          packageAssetPathsClass
              .writeln("  static const $propertyName = \"${assetPath}\";");
          packageAssetPathsClass.writeln();
        });
        packageAssetPathsClass.writeln(ignoreForFile);
        packageAssetPathsClass.writeln('}');
      });
    }

    return packageAssetPathsClass.toString();
  }

  Future<YamlMap> _createPubspecYampMap(BuildStep buildStep) async {
    final pubspecAssetId = AssetId(buildStep.inputId.package, 'pubspec.yaml');
    final pubspecContent = await buildStep.readAsString(pubspecAssetId);
    return loadYaml(pubspecContent);
  }

  Set<String> _getPackagesFromPubspec(YamlMap pubspecYamlMap) {
    if (pubspecYamlMap.containsKey("dependencies")) {
      final dependenciesMap = pubspecYamlMap["dependencies"];
      if (dependenciesMap is YamlMap) {
        return Set.from(dependenciesMap.keys);
      }
    }

    return {};
  }

  Set<String> _getAssetsListFromPubspec(YamlMap pubspecYamlMap) {
    if (pubspecYamlMap.containsKey("flutter")) {
      final flutterMap = pubspecYamlMap["flutter"];
      if (flutterMap is YamlMap && flutterMap.containsKey("assets")) {
        YamlList assetsList = flutterMap["assets"];

        // It's valid that set the same asset path multiple times in pubspec.yaml,
        // so the assets can be duplicate, use `Set` here to filter the same asset path.
        return Set.from(assetsList);
      }
    }

    return {};
  }

  /// Get `assets` value from `pubspec.yaml` file.
  Set<Glob> _createAssetsListGlob(YamlMap pubspecYamlMap) {
    Set<Glob> globList = {};
    for (final asset in _getAssetsListFromPubspec(pubspecYamlMap)) {
      if (asset.endsWith("/")) {
        globList.add(Glob("$asset*"));
      } else {
        globList.add(Glob(asset));
      }
    }

    return globList;
  }

  Future<List<String>> _findAssetIdPathsFromFlutterAssetsList(
      BuildStep buildStep, YamlMap pubspecYamlMap) async {
    final globList = _createAssetsListGlob(pubspecYamlMap);
    Set<AssetId> assetsSet = {};
    // On iOS it will create a .DS_Store file in assets folder, so use
    // the regular expression to match the valid assets path.
    final rexp = RegExp(r'^([a-zA-Z0-9]+\/)*([a-zA-Z0-9]+.)+\.[a-z]+');
    for (final glob in globList) {
      final assets = await buildStep.findAssets(glob).toList();
      assetsSet.addAll(assets.where((e) => rexp.hasMatch(e.path)));
    }

    return assetsSet.map((e) => e.path).toList();
  }

  /// Create [_AssetsScannerOptions] from `assets_scanner_options.yaml` file
  _AssetsScannerOptions _getOptions() {
    final optionsFile = File("assets_scanner_options.yaml");
    if (optionsFile.existsSync()) {
      final optionsContent = optionsFile.readAsStringSync();
      if (optionsContent?.isNotEmpty ?? false) {
        return _AssetsScannerOptions.fromYamlMap(loadYaml(optionsContent));
      }
    }

    return _AssetsScannerOptions();
  }
}
